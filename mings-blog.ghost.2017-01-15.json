{"db":[{"meta":{"exported_on":1484495841235,"version":"004"},"data":{"posts":[{"id":3,"uuid":"9512bcec-31e4-444d-9432-59436d7fa35b","title":"hello ghost","slug":"hello-ghost","markdown":"2015.09开始断断续续地弄个人博客,用hexo,发了一篇文章,无奈文章发布太麻烦,到了2015年最后一天都没有再发一篇文章.\n\n2016年即将开始,我也将有新的开始,弄好blog开始写一些文章不论是生活还是技术.\n\nhello ghost!\nhello 2016! \n","html":"<p>2015.09开始断断续续地弄个人博客,用hexo,发了一篇文章,无奈文章发布太麻烦,到了2015年最后一天都没有再发一篇文章.</p>\n\n<p>2016年即将开始,我也将有新的开始,弄好blog开始写一些文章不论是生活还是技术.</p>\n\n<p>hello ghost! <br />\nhello 2016! </p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1451577650659,"created_by":1,"updated_at":1462192106838,"updated_by":1,"published_at":1451577657409,"published_by":1},{"id":4,"uuid":"2372de87-6aa4-4f1c-9c4f-3350fbddb86f","title":"about","slug":"about-me","markdown":"## 我\n+ CQUPT 14级 通信\n\n+ 联系我:\n  - QQ: 971334483\n  - email: i@todoit.me\n\n+ 关于我\n  - 主要在写前端\n  - bboy (静若处子动若脱兔的舞者和程序员\n  - 向往CS的EE狗\n\n## 这个blog\n  + 其实我内心是想写博客的, 然而老是拖.","html":"<h2 id=\"\">我</h2>\n\n<ul>\n<li><p>CQUPT 14级 通信</p></li>\n<li><p>联系我:</p>\n\n<ul><li>QQ: 971334483</li>\n<li>email: i@todoit.me</li></ul></li>\n<li><p>关于我</p>\n\n<ul><li>主要在写前端</li>\n<li>bboy (静若处子动若脱兔的舞者和程序员</li>\n<li>向往CS的EE狗</li></ul></li>\n</ul>\n\n<h2 id=\"blog\">这个blog</h2>\n\n<ul>\n<li>其实我内心是想写博客的, 然而老是拖.</li>\n</ul>","image":null,"featured":0,"page":1,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1451578696765,"created_by":1,"updated_at":1483880871818,"updated_by":1,"published_at":1451579618781,"published_by":1},{"id":5,"uuid":"597e78db-c928-4342-b711-eb0b114b6173","title":"Fisher-Yates-shuffle洗牌算法","slug":"fisher-yates-shufflexi-pai-suan-fa","markdown":"#Fisher-Yates-shuffle洗牌算法\n\n最近在看underscorejs的时候看到了_.shuffle (打乱集合)用的就是这个Fisher-Yates-shuffle算法,然后在_.simple(取样,从集合中随机取n个元素)中很好的依赖了_.shuffle\n\n我不由得想起以前写通信软件基础作业的时候懵逼懵逼的想从数组中随机取n个元素该怎么\n避免随机数重复\n\n以下是underscore中的实现\n\nshuffle: \n    \n    _.shuffle = function(obj) {\n        var set = obj && obj.length === +obj.length ? obj : _.values(obj);\n        var length = set.length;\n        var shuffled = Array(length);\n        for (var index = 0, rand; index < length; index++) {\n            rand = _.random(0, index);     // 产生0到index的随机数\n            if (rand !== index) \n                shuffled[index] = shuffled[rand];\n            shuffled[rand] = set[index];\n        }\n        return shuffled;\n     };\n\n\n sample:\n\n     _.sample = function(obj, n, guard) {\n        if (n == null || guard) {\n            if (obj.length !== +obj.length) obj = _.values(obj);\n            return obj[_.random(obj.length - 1)];\n        }\n        return _.shuffle(obj).slice(0, Math.max(0, n));\n    };\n\nsample依赖于shuffle,先用shuffle將集合打乱,再从中取出n个元素,这个效果就和从集合中任取n个元素是一样的了,不得不说这个依赖很巧妙,反正我是没想到过.\n\n以下简绍一下shuffle的算法\n\n + Fisher–Yates shuffle\n\n Fisher–Yates shuffle(以Ronald Fisher和Frank Yates的名字命名的) 最早在1938年Ronald Fisher和Frank Yates的书*tatistical tables for biological, agricultural and medical research*里被描述,他们是这样描述这个算法的(其实是我自己理解翻译的,毕竟1938年哪有什么数组啊):\n  1. 有一个长度为len的数组arr\n\n  2. 生成一个0到len的随机数rand\n\n  3. 將array[rand]取出push到另一个数组shuffledArr(此时len减1了)\n\n  4. 重复2,3步直到arr中没有元素\n\n js 代码实现:\n\n        function randomRange(min, max) {\n      \t  if(max == null) {\n                max = min;\n    \t    \tmin = 0;\n            }\n            return min + Math.floor(Math.random() * (max - min +1));\n        }\n\n        function shuffle(arr) {\n            var rand = 0,\n                temp = 0,\n                shuffledArr = [];\n            \n           while(arr[0] !== void 0) {\n               rand = randomRange(0, arr.length);\n               temp = arr.splice(rand, 1)[0];       // 取出第rand个元素\n               shuffledArr.push(temp);\n           }\n        return shuffledArr;\n        }\n\n 但是这样因为删除数组中的元素的时候要前移\n所以时间复杂度是O(n<sup>2</sup>)\n\n  + Knuth-Durstenfeld Shuffle\n\n     到了1964年,这个算法的现代版本被Richard Durstenfeld提出,随着Donald E. Knuth的(The Art of Computer Programming)[http://]被推广\nDurstenfeld和Knuth在Fisher和Yates的基础上改进了这个算法\n时间复杂度从O(n<sup>2</sup>)降低到了O(n);\n\n 来看看伪代码描述\n    \n        -- To shuffle an array a of n elements (indices 0..n-1):\n\t        for i from n−1 downto 1 do\t\t\t\t\t\n    \t        j ← random integer such that 0 ≤ j ≤ i \t\t// 生成一个从0到i的随机数\n     \t       exchange a[j] and a[i] \t\t\t\t\t\t// 交换j和i的值\n\n js实现:\n\t\n        function shuffle(arr) {\n            var rand,\n                temp;\t\n            for(var i = 0, len = arr.length; i < len; i++) {\n                rand = randomRange(i);\n                temp = arr[rand];\n                arr[rand] = arr[i]\n                arr[i] = temp;\n            }\n            return arr;\n        }\n\n 但是这个算法是一个in-place shuffle(就地洗牌),打乱了原始数据,我们有时候希望原始数据不会被打乱,所以我们需要另一个不打乱原始数据的算法\n\n + The \"inside-out\" algorithm\n\n Inside-Out Algorithm 算法的基本思想是设一个迭代器i从前向后扫描原始数据，在[0, i]之间生成一个随机数rand，然后对拷贝数据用下标为rand的元素替换掉位置i的元素，再用原始数据位置i的元素替换掉拷贝数据位置rand的元素。其作用相当于在拷贝数据中交换i与rand位置处的值。 伪代码如下：\n\n        To initialize an array a of n elements to a randomly shuffled copy of source, both 0-based:\n  \t\tfor i from 0 to n − 1 do\n      \t    j ← random integer such that 0 ≤ j ≤ i\n      \t       if j ≠ i\n                    a[i] ← a[j]\n                 a[j] ← source[i]\n\n js实现:\n    \n        function shuffle(arr) {\n            var len = arr.len,\n                shuffledArr = Array(len);\n                for(var i = 0, rand; i < len; i++) {\n                    rand = randomRange(i);\n                    if(rand !== i) shuffledArr[i] = shuffledArr[rand];\n                    shuffledArr[rand] = arr[i];\n                }\n                return shuffledArr;\n        }\n 其实这样就和underscore里面的实现一样一样的了~不过我写这个没有考虑集合\n\n参考: [Fisher-Yates-shuffle --wikipedia](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle)","html":"<h1 id=\"fisheryatesshuffle\">Fisher-Yates-shuffle洗牌算法</h1>\n\n<p>最近在看underscorejs的时候看到了<em>.shuffle (打乱集合)用的就是这个Fisher-Yates-shuffle算法,然后在</em>.simple(取样,从集合中随机取n个元素)中很好的依赖了_.shuffle</p>\n\n<p>我不由得想起以前写通信软件基础作业的时候懵逼懵逼的想从数组中随机取n个元素该怎么\n避免随机数重复</p>\n\n<p>以下是underscore中的实现</p>\n\n<p>shuffle: </p>\n\n<pre><code>_.shuffle = function(obj) {\n    var set = obj &amp;&amp; obj.length === +obj.length ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index &lt; length; index++) {\n        rand = _.random(0, index);     // 产生0到index的随机数\n        if (rand !== index) \n            shuffled[index] = shuffled[rand];\n        shuffled[rand] = set[index];\n    }\n    return shuffled;\n };\n</code></pre>\n\n<p>sample:</p>\n\n<pre><code> _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n        if (obj.length !== +obj.length) obj = _.values(obj);\n        return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n};\n</code></pre>\n\n<p>sample依赖于shuffle,先用shuffle將集合打乱,再从中取出n个元素,这个效果就和从集合中任取n个元素是一样的了,不得不说这个依赖很巧妙,反正我是没想到过.</p>\n\n<p>以下简绍一下shuffle的算法</p>\n\n<ul>\n<li><p>Fisher–Yates shuffle</p>\n\n<p>Fisher–Yates shuffle(以Ronald Fisher和Frank Yates的名字命名的) 最早在1938年Ronald Fisher和Frank Yates的书<em>tatistical tables for biological, agricultural and medical research</em>里被描述,他们是这样描述这个算法的(其实是我自己理解翻译的,毕竟1938年哪有什么数组啊):</p>\n\n<ol><li><p>有一个长度为len的数组arr</p></li>\n<li><p>生成一个0到len的随机数rand</p></li>\n<li><p>將array[rand]取出push到另一个数组shuffledArr(此时len减1了)</p></li>\n<li><p>重复2,3步直到arr中没有元素</p></li></ol>\n\n<p>js 代码实现:</p>\n\n<pre><code>function randomRange(min, max) {\n    if(max == null) {\n        max = min;\n        min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min +1));\n}\n\n\nfunction shuffle(arr) {\n    var rand = 0,\n        temp = 0,\n        shuffledArr = [];\n\n\n   while(arr[0] !== void 0) {\n       rand = randomRange(0, arr.length);\n       temp = arr.splice(rand, 1)[0];       // 取出第rand个元素\n       shuffledArr.push(temp);\n   }\nreturn shuffledArr;\n}\n</code></pre>\n\n<p>但是这样因为删除数组中的元素的时候要前移\n所以时间复杂度是O(n<sup>2</sup>)</p>\n\n<ul><li><p>Knuth-Durstenfeld Shuffle</p>\n\n<p>到了1964年,这个算法的现代版本被Richard Durstenfeld提出,随着Donald E. Knuth的(The Art of Computer Programming)[http://]被推广\nDurstenfeld和Knuth在Fisher和Yates的基础上改进了这个算法 <br />\n时间复杂度从O(n<sup>2</sup>)降低到了O(n);</p></li></ul>\n\n<p>来看看伪代码描述</p>\n\n<pre><code>-- To shuffle an array a of n elements (indices 0..n-1):\n    for i from n−1 downto 1 do                  \n        j ← random integer such that 0 ≤ j ≤ i      // 生成一个从0到i的随机数\n        exchange a[j] and a[i]                       // 交换j和i的值\n</code></pre>\n\n<p>js实现:</p>\n\n<pre><code>function shuffle(arr) {\n    var rand,\n        temp;    \n    for(var i = 0, len = arr.length; i &lt; len; i++) {\n        rand = randomRange(i);\n        temp = arr[rand];\n        arr[rand] = arr[i]\n        arr[i] = temp;\n    }\n    return arr;\n}\n</code></pre>\n\n<p>但是这个算法是一个in-place shuffle(就地洗牌),打乱了原始数据,我们有时候希望原始数据不会被打乱,所以我们需要另一个不打乱原始数据的算法</p></li>\n<li><p>The \"inside-out\" algorithm</p>\n\n<p>Inside-Out Algorithm 算法的基本思想是设一个迭代器i从前向后扫描原始数据，在[0, i]之间生成一个随机数rand，然后对拷贝数据用下标为rand的元素替换掉位置i的元素，再用原始数据位置i的元素替换掉拷贝数据位置rand的元素。其作用相当于在拷贝数据中交换i与rand位置处的值。 伪代码如下：</p>\n\n<pre><code>To initialize an array a of n elements to a randomly shuffled copy of source, both 0-based:\n  for i from 0 to n − 1 do\n      j ← random integer such that 0 ≤ j ≤ i\n         if j ≠ i\n            a[i] ← a[j]\n         a[j] ← source[i]\n</code></pre>\n\n<p>js实现:</p>\n\n<pre><code>function shuffle(arr) {\n    var len = arr.len,\n        shuffledArr = Array(len);\n        for(var i = 0, rand; i &lt; len; i++) {\n            rand = randomRange(i);\n            if(rand !== i) shuffledArr[i] = shuffledArr[rand];\n            shuffledArr[rand] = arr[i];\n        }\n        return shuffledArr;\n}\n</code></pre>\n\n<p>其实这样就和underscore里面的实现一样一样的了~不过我写这个没有考虑集合</p></li>\n</ul>\n\n<p>参考: <a href=\"http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\">Fisher-Yates-shuffle --wikipedia</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1453997479075,"created_by":1,"updated_at":1462192061630,"updated_by":1,"published_at":1454169729946,"published_by":1},{"id":7,"uuid":"de4f6260-ddb8-4444-b24f-5c3c4a385d2a","title":"JavaScript从观察者模式到eventEmitter","slug":"javascript-observer-event","markdown":"观察者者模式\n\n很早以前写了一篇关于观察者模式(发布订阅模式)的简单实现, 现在有了新的感悟, 捡起来再啃啃.\n\n先上维基百科看看: \n\n观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。\n\n\n\n理解起来很简单: 我去书报亭订了一份报纸,当他把报纸送给我了,我就去领了看.\n\n这里,我就变成了订阅者,报亭就是发布者,当报纸送到的时候(状态发生改变,通知订阅者),我就去领了看(做一些操作).\n\n我们看到, 订阅者模式有两个实体, 一个发布者, 一个是订阅者.\n\n\n\n发布者有三个功能: 订阅, 发布, 退订.\n\n\n\n简单到爆炸的版本\n\n🤓让我们动手来写一个试试.\n\n\n\n订阅功能: \n\n    let Publisher = {};\n    let eventQueue = {}; // 存事件, 一个事件名对应一个函数\n    \n    publisher.subscribe = function(event, listener) {\n         eventQueue[event] = listener;\n    }\n\n发布功能: \n\n    publisher.publish = function(event) {\n        let listener = eventQueue[event];\n        listener && listener();             // 如果存在, 则调用监听器\n    }\n\n退订功能: \n\n    // 将监听器从 eventQueue 删除(设为 null)\n    publisher.off = function(event, listener) {   \n        if(!eventQueue[event]) return;\n        eventQueue[event] = null;\n    }\n\n这样, 我们就实现了一个简陋的观察者模式了\n\n    publisher.subscribe(\"eventA\", function() {\n    \tconsole.log(\"eventA, publish!\");\n    });\n    publisher.publish(\"eventA\");     // eventA, publish!\"\n\n但是这样也太简陋了, eventQueue 都是暴露在外的, 而且一个事件只能订阅一个操作而且没办法传参.\n\n\n\n完善一下\n\n让我们改进一下, 加入给事件监听器传参的功能, 一个事件注册多个监听器\n\n    let publisher = (function(){\n        let eventQueue = {};  // 将事件存在闭包中, 每一个事件,保存一个监听器数组\n        \n      \treturn {\n          \n            subscribe(event, listener) {\n                if(eventQueue[event]) {\n                    eventQueue[event].push(listener);\n                } else {\n                    eventQueue[event] = [];\n                    eventQueue[event].push(listener);\n                }\n              \n              \t// 下面这个写法简单些, 但是不好读..\n              \t// (eventQueue[event] = eventQueue[event] || []).push(listener);\n            },\n          \n    \t\n            publish(event, ...args) {\n                let listeners = eventQueue[event];\n                if(!listeners) return;\n                listeners.forEach((listener) => {\n                    listener(...args);\n                })\n            },\n          \n          \n            off(event, listener) {\n                let listeners = eventQueue[event];\n                eventQueue[event] = listeners.filter((l) => {\n                    return l !== listener;\n                });\n            }\n        }\n    }());\n    \n    // 测试\n    function listener(a, b) {\n        console.log(`a: ${a}`);\n        console.log(`b: ${b}`);\n    }\n    \n    publisher.subscribe(\"eventA\", listener);\n    publisher.publish(\"eventA\", \"hello\", \"world\"); //a: hello\n    \t\t\t\t\t\t\t\t\t\t   //b: world\n    publisher.off(\"eventA\", listener);\n    publisher.publish(\"eventA\", \"hello\", \"world\"); // 没输出东西的\n\n这样, 我们就实现了一个简单的观察者模式了. (但是这样一点也不 OO啊)\n\n让我把它封装成一个类, 这样它就 OO了.\n\n\n\n    function Publisher() {\n        this.event = {};\n    }\n\n\n\n    Publisher.prototype.subscribe = function(event, listener) {\n        if(this.eventQueue[event]) {\n            this.eventQueue[event].push(listener);\n        } else {\n            this.eventQueue[event] = [];\n            this.eventQueue[event].push(listener);\n        }\n    }\n\n\n\n    Publisher.prototype.publish = function(event, ...args) {\n        let listeners = this.eventQueue[event];\n        if(!listeners) return;\n        listeners.forEach((listener) => {\n            listener(...args);\n        });\n    }\n\n\n\n    Publisher.prototype.off = function(event, listener) {\n        let listeners = this.eventQueue[event];\n        this.eventQueue[event] = listeners.filter((l) => {\n            return l !== listener;\n        });\n    }\n\n\n\n用起来试试: \n\n    let publisher = new Publisher();\n    \n    publisher.subscribe(\"eventA\", listener);\n    publisher.publish(\"eventA\", \"hello\", \"world\"); // a: hello b: world\n    publisher.off(\"eventA\", listener);\n    publisher.publish(\"eventA\", \"hello\", \"world\"); // 没输出\n\nOK 辣, 功能也还算完善\n\n然而, 如果是老司机, 一眼就能看出来, 其实这个东西是和 node 的 EventEmitter 很像的: 添加事件监听, 发布事件.\n\n\n\n我们只需要改该名字, 就可以伪装成 node 的 EventEmitter 了\n\nFBI warning: 下面代码其实和上面是一样的, 只是改了属性方法名而已;\n\n    function EventEmitter() {\n        this._eventQueue = {};\n    }\n    EventEmitter.prototype.on = function(event, listener) {\n        if(this._eventQueue[event]) {\n            this._eventQueue[event].push(listener);\n        } else {\n            this._eventQueue[event] = [];\n            this.eventQuone[event].push(listener);\n        }\n    }\n    \n    EventEmitter.prototype.emit = function(event, ...args) {\n        let listeners = this._eventQueue[event];\n        if(!listeners) return;\n        listeners.forEach((listener) => {\n            listener(...args);\n        });\n    }\n    \n    EventEmitter.prototype.off = function(event, listener) {\n        let listeners = this._eventQueue[event];\n        this._eventQueue[event] = listeners.filter((l) => {\n            return l !== listener;\n        });\n    }\n    \n    let emitter = new Emitter();\n    emitter.on(\"request\", function() {\n    \tconsole.log(\"on request\");\n    });\n    emitter.emit(\"request\");\n    // do some thing\n\n\n\n事件\n\n然而, 我们写那么多有什么用?\n\nEventEmitter 是 node 的核心模块, 回忆一下,\n\n写 nodejs 代码的时候, 是不是经常写一些事件监听?\n\n举个例子: \n\n    http.createServer(function(request, response) {\n    \trequest.on(\"data\", function() {\n    \t\t// do something\n        });\n    })\n\n其实, 看似简单的代码, 背后总是隐藏着后面无数代码的辛勤工作\n\nrequest 是 http.IncomingMessage 类的一个实例, (每一个请求, 都会 new 一个http.IncomingMessage 然后传入到上面的匿名函数里面去);\n\n http.IncomingMessage 类直接继承了 EventEmitter 类\n\n\n\n以下请假装是伪代码, 简单模拟了一下\n\n    let http = require('http');\n    let events = require('event');\n    \n    \n    /***********************\n    \t假装这里是http模块里的代码\n    ***********************/\n    http.IncomingMessage = function() {\n    \tevents.EventEmitter.call(this);\n    \t// something else\n    }\n    utils.inherits(http.IncomingMessage, events.EventEmitter);\n    \n    \n    /******************\n    createSever \n    *******************/\n    \n    http.createServer = function(listener) {\n      // balabala\n    \tlet request = new http.IncomingMessage();\n      \tlistenter(request, response);   // response就不写了\n      // do something\n    }\n    \n    \n    /*****************\n    \t这里,你 create 了一个 http server\n        request 其实是 IncomingMessage 的实例\n    \n    ****************/\n    http.createServer(function(request, response) {\n    \trequest.on(\"data\", function(data) {\n    \t\t// do something\n        });\n    });\n    \n    \n    /***********\n    \t你写完上面那里以后, eventEmitter 默默的把你上面的匿名函数放到事件队列里面了\n    **************/\n    \n    \n    // 看这里\n    \n    /****\n    \t然后用户发了一些数据, 比如请求\n    \t\n    \t然后运行 这段代码:  request.emit('data', data);\n    \t然后你添加的事件监听函数就运行了\n    ****/\n    \n    //over\n\n以上大致就是request 事件订阅和发布的过程了.\n\n觉得太麻烦不想看?\n\n我们来看看简单的用法: \n\n如果你需要在代码中使用事件\n\n你只需要: \n\n    function YourClass() {\n    \tEventEmitter.call(this);\n    }\n    utils.inherts(YourClass, EventEmitter);\n\n这样, YourClass 类的实例, 就可以用 on, emitter 去添加和发布事件了\n\n\n\n然而, 我不用给自己的类添加事件也能写出功能来啊\n\n这个事件类, 其实可以让你的代码减少嵌套举个例子, 以下代码不能运行\n\n    app.get(function(req, res) {\n    \tlet xxx = req.params['xxx'];\n    \tmysql.query('select * from table where xxx=$', [xxx], function(result) {\n        \tmysql.query('select * from table where xxx=${result}', function() {\n    \t\t\t// do something\n    \t\t});\n    \t});\n    })\n\n\n\n    emitter.on(\"queryxxx\", function(result) {\n      mysql.query('select * from table where xxx=${result}', function() {\n        // do something\n      });\n    });\n    \n    app.get(function(req, res) {\n      let xxx = req.params['xxx'];\n      mysql.query('select * from table where xxx=$', [xxx], function(result) {\n        emitter.emit(\"queryxxx\", result);\n      })\n    })\n\n可以看到事件可以减少代码嵌套过深的问题\n\n(  当然其实用 promise, yeild也可以解决, 而且优雅的多.\n\n然而其实它的作用当然不是这么简单的.\n\n观察者模式更多的用于前端的 MV*框架\n\n大概是这样:    数据改变->发布数据改变的事件-> 渲染页面\n\n模拟一下: \n\n    data.on(\"change\", function() {\n    \t// 渲染页面, 和做一些其他的事情\n    });\n    \n    // 向框架使用者提供改变 data 的接口 \n    data.setData = function(data) {\n    \t// do something\n      \tdata.emit(\"change\", data);\n    }\n\n在 js 中,如果只是针对数据的改变触发事件的话,其实 getter, setter 是更好的选择, 很多框架就是使用了 getter, setter 实现的\n","html":"<p>观察者者模式</p>\n\n<p>很早以前写了一篇关于观察者模式(发布订阅模式)的简单实现, 现在有了新的感悟, 捡起来再啃啃.</p>\n\n<p>先上维基百科看看: </p>\n\n<p>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。</p>\n\n<p>理解起来很简单: 我去书报亭订了一份报纸,当他把报纸送给我了,我就去领了看.</p>\n\n<p>这里,我就变成了订阅者,报亭就是发布者,当报纸送到的时候(状态发生改变,通知订阅者),我就去领了看(做一些操作).</p>\n\n<p>我们看到, 订阅者模式有两个实体, 一个发布者, 一个是订阅者.</p>\n\n<p>发布者有三个功能: 订阅, 发布, 退订.</p>\n\n<p>简单到爆炸的版本</p>\n\n<p>🤓让我们动手来写一个试试.</p>\n\n<p>订阅功能: </p>\n\n<pre><code>let Publisher = {};\nlet eventQueue = {}; // 存事件, 一个事件名对应一个函数\n\npublisher.subscribe = function(event, listener) {\n     eventQueue[event] = listener;\n}\n</code></pre>\n\n<p>发布功能: </p>\n\n<pre><code>publisher.publish = function(event) {\n    let listener = eventQueue[event];\n    listener &amp;&amp; listener();             // 如果存在, 则调用监听器\n}\n</code></pre>\n\n<p>退订功能: </p>\n\n<pre><code>// 将监听器从 eventQueue 删除(设为 null)\npublisher.off = function(event, listener) {   \n    if(!eventQueue[event]) return;\n    eventQueue[event] = null;\n}\n</code></pre>\n\n<p>这样, 我们就实现了一个简陋的观察者模式了</p>\n\n<pre><code>publisher.subscribe(\"eventA\", function() {\n    console.log(\"eventA, publish!\");\n});\npublisher.publish(\"eventA\");     // eventA, publish!\"\n</code></pre>\n\n<p>但是这样也太简陋了, eventQueue 都是暴露在外的, 而且一个事件只能订阅一个操作而且没办法传参.</p>\n\n<p>完善一下</p>\n\n<p>让我们改进一下, 加入给事件监听器传参的功能, 一个事件注册多个监听器</p>\n\n<pre><code>let publisher = (function(){\n    let eventQueue = {};  // 将事件存在闭包中, 每一个事件,保存一个监听器数组\n\n      return {\n\n        subscribe(event, listener) {\n            if(eventQueue[event]) {\n                eventQueue[event].push(listener);\n            } else {\n                eventQueue[event] = [];\n                eventQueue[event].push(listener);\n            }\n\n              // 下面这个写法简单些, 但是不好读..\n              // (eventQueue[event] = eventQueue[event] || []).push(listener);\n        },\n\n\n        publish(event, ...args) {\n            let listeners = eventQueue[event];\n            if(!listeners) return;\n            listeners.forEach((listener) =&gt; {\n                listener(...args);\n            })\n        },\n\n\n        off(event, listener) {\n            let listeners = eventQueue[event];\n            eventQueue[event] = listeners.filter((l) =&gt; {\n                return l !== listener;\n            });\n        }\n    }\n}());\n\n// 测试\nfunction listener(a, b) {\n    console.log(`a: ${a}`);\n    console.log(`b: ${b}`);\n}\n\npublisher.subscribe(\"eventA\", listener);\npublisher.publish(\"eventA\", \"hello\", \"world\"); //a: hello\n                                           //b: world\npublisher.off(\"eventA\", listener);\npublisher.publish(\"eventA\", \"hello\", \"world\"); // 没输出东西的\n</code></pre>\n\n<p>这样, 我们就实现了一个简单的观察者模式了. (但是这样一点也不 OO啊)</p>\n\n<p>让我把它封装成一个类, 这样它就 OO了.</p>\n\n<pre><code>function Publisher() {\n    this.event = {};\n}\n\n\n\nPublisher.prototype.subscribe = function(event, listener) {\n    if(this.eventQueue[event]) {\n        this.eventQueue[event].push(listener);\n    } else {\n        this.eventQueue[event] = [];\n        this.eventQueue[event].push(listener);\n    }\n}\n\n\n\nPublisher.prototype.publish = function(event, ...args) {\n    let listeners = this.eventQueue[event];\n    if(!listeners) return;\n    listeners.forEach((listener) =&gt; {\n        listener(...args);\n    });\n}\n\n\n\nPublisher.prototype.off = function(event, listener) {\n    let listeners = this.eventQueue[event];\n    this.eventQueue[event] = listeners.filter((l) =&gt; {\n        return l !== listener;\n    });\n}\n</code></pre>\n\n<p>用起来试试: </p>\n\n<pre><code>let publisher = new Publisher();\n\npublisher.subscribe(\"eventA\", listener);\npublisher.publish(\"eventA\", \"hello\", \"world\"); // a: hello b: world\npublisher.off(\"eventA\", listener);\npublisher.publish(\"eventA\", \"hello\", \"world\"); // 没输出\n</code></pre>\n\n<p>OK 辣, 功能也还算完善</p>\n\n<p>然而, 如果是老司机, 一眼就能看出来, 其实这个东西是和 node 的 EventEmitter 很像的: 添加事件监听, 发布事件.</p>\n\n<p>我们只需要改该名字, 就可以伪装成 node 的 EventEmitter 了</p>\n\n<p>FBI warning: 下面代码其实和上面是一样的, 只是改了属性方法名而已;</p>\n\n<pre><code>function EventEmitter() {\n    this._eventQueue = {};\n}\nEventEmitter.prototype.on = function(event, listener) {\n    if(this._eventQueue[event]) {\n        this._eventQueue[event].push(listener);\n    } else {\n        this._eventQueue[event] = [];\n        this.eventQuone[event].push(listener);\n    }\n}\n\nEventEmitter.prototype.emit = function(event, ...args) {\n    let listeners = this._eventQueue[event];\n    if(!listeners) return;\n    listeners.forEach((listener) =&gt; {\n        listener(...args);\n    });\n}\n\nEventEmitter.prototype.off = function(event, listener) {\n    let listeners = this._eventQueue[event];\n    this._eventQueue[event] = listeners.filter((l) =&gt; {\n        return l !== listener;\n    });\n}\n\nlet emitter = new Emitter();\nemitter.on(\"request\", function() {\n    console.log(\"on request\");\n});\nemitter.emit(\"request\");\n// do some thing\n</code></pre>\n\n<p>事件</p>\n\n<p>然而, 我们写那么多有什么用?</p>\n\n<p>EventEmitter 是 node 的核心模块, 回忆一下,</p>\n\n<p>写 nodejs 代码的时候, 是不是经常写一些事件监听?</p>\n\n<p>举个例子: </p>\n\n<pre><code>http.createServer(function(request, response) {\n    request.on(\"data\", function() {\n        // do something\n    });\n})\n</code></pre>\n\n<p>其实, 看似简单的代码, 背后总是隐藏着后面无数代码的辛勤工作</p>\n\n<p>request 是 http.IncomingMessage 类的一个实例, (每一个请求, 都会 new 一个http.IncomingMessage 然后传入到上面的匿名函数里面去);</p>\n\n<p>http.IncomingMessage 类直接继承了 EventEmitter 类</p>\n\n<p>以下请假装是伪代码, 简单模拟了一下</p>\n\n<pre><code>let http = require('http');\nlet events = require('event');\n\n\n/***********************\n    假装这里是http模块里的代码\n***********************/\nhttp.IncomingMessage = function() {\n    events.EventEmitter.call(this);\n    // something else\n}\nutils.inherits(http.IncomingMessage, events.EventEmitter);\n\n\n/******************\ncreateSever \n*******************/\n\nhttp.createServer = function(listener) {\n  // balabala\n    let request = new http.IncomingMessage();\n      listenter(request, response);   // response就不写了\n  // do something\n}\n\n\n/*****************\n    这里,你 create 了一个 http server\n    request 其实是 IncomingMessage 的实例\n\n****************/\nhttp.createServer(function(request, response) {\n    request.on(\"data\", function(data) {\n        // do something\n    });\n});\n\n\n/***********\n    你写完上面那里以后, eventEmitter 默默的把你上面的匿名函数放到事件队列里面了\n**************/\n\n\n// 看这里\n\n/****\n    然后用户发了一些数据, 比如请求\n\n    然后运行 这段代码:  request.emit('data', data);\n    然后你添加的事件监听函数就运行了\n****/\n\n//over\n</code></pre>\n\n<p>以上大致就是request 事件订阅和发布的过程了.</p>\n\n<p>觉得太麻烦不想看?</p>\n\n<p>我们来看看简单的用法: </p>\n\n<p>如果你需要在代码中使用事件</p>\n\n<p>你只需要: </p>\n\n<pre><code>function YourClass() {\n    EventEmitter.call(this);\n}\nutils.inherts(YourClass, EventEmitter);\n</code></pre>\n\n<p>这样, YourClass 类的实例, 就可以用 on, emitter 去添加和发布事件了</p>\n\n<p>然而, 我不用给自己的类添加事件也能写出功能来啊</p>\n\n<p>这个事件类, 其实可以让你的代码减少嵌套举个例子, 以下代码不能运行</p>\n\n<pre><code>app.get(function(req, res) {\n    let xxx = req.params['xxx'];\n    mysql.query('select * from table where xxx=$', [xxx], function(result) {\n        mysql.query('select * from table where xxx=${result}', function() {\n            // do something\n        });\n    });\n})\n\n\n\nemitter.on(\"queryxxx\", function(result) {\n  mysql.query('select * from table where xxx=${result}', function() {\n    // do something\n  });\n});\n\napp.get(function(req, res) {\n  let xxx = req.params['xxx'];\n  mysql.query('select * from table where xxx=$', [xxx], function(result) {\n    emitter.emit(\"queryxxx\", result);\n  })\n})\n</code></pre>\n\n<p>可以看到事件可以减少代码嵌套过深的问题</p>\n\n<p>(  当然其实用 promise, yeild也可以解决, 而且优雅的多.</p>\n\n<p>然而其实它的作用当然不是这么简单的.</p>\n\n<p>观察者模式更多的用于前端的 MV*框架</p>\n\n<p>大概是这样:    数据改变->发布数据改变的事件-> 渲染页面</p>\n\n<p>模拟一下: </p>\n\n<pre><code>data.on(\"change\", function() {\n    // 渲染页面, 和做一些其他的事情\n});\n\n// 向框架使用者提供改变 data 的接口 \ndata.setData = function(data) {\n    // do something\n      data.emit(\"change\", data);\n}\n</code></pre>\n\n<p>在 js 中,如果只是针对数据的改变触发事件的话,其实 getter, setter 是更好的选择, 很多框架就是使用了 getter, setter 实现的</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1462175920853,"created_by":1,"updated_at":1480904542286,"updated_by":1,"published_at":1462186078244,"published_by":1},{"id":8,"uuid":"ce121d19-4e23-4df4-9a65-3e401460d1d1","title":"friends","slug":"friends","markdown":"+ [alkalixin](https://www.alkalixin.cn/)\n+ [hangeer](http://www.hangeer1996.com/)","html":"<ul>\n<li><a href=\"https://www.alkalixin.cn/\">alkalixin</a></li>\n<li><a href=\"http://www.hangeer1996.com/\">hangeer</a></li>\n</ul>","image":null,"featured":0,"page":1,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464508275117,"created_by":1,"updated_at":1464508412381,"updated_by":1,"published_at":1464508412382,"published_by":1},{"id":9,"uuid":"7821f0d0-6a3a-43a6-9ba8-05ca465eec59","title":"编程语言强弱类型,动静类型之分","slug":"bian-cheng-yu-yan-qiang-ruo-lei-xing-dong-jing-lei-xing-zhi-fen-md","markdown":"最近用空闲时间看了一本书<冒号课堂>,内容虽然宽泛,但是仍读到了一些有用的知识,并纠正了一些关于语言上的错误概念.\n\n\n\n+ 数据类型包含两个要素:\n    \n    1. 允许取值的集合\n    2. 允许参与的运算\n      如: int在java中既定义了-2的31次方和2的31次方减一的整数集合, 也定义了该集合上的整数能进行的运算 \n\n\n+ 数据类型的意义\n\n> 限定一个变量的数据类型，就意味着限制了该变量的取值范围和所参与的运算，这从一定程度上保证了代码的安全性\n\n\n\n## 动静态类型语言\n\n+ 动态类型语言\n  类型检查发生在运行期间,编译的时候就知道每一个变量的类型,因为类型错误而不能做的事情是语法错误.\n\n    python,php,javascript是动态类型的\n\n+ 静态类型语言\n  类型检查发生在运行之前,编译的时候不知道每一个变量的类型,因为类型错误而不能做的事情是运行时错误.譬如说你不能对一个数字 a 写 a[10] 当数组用,并且可以在运行期间改变变量的类型\n\n    例如: `a = 0; a = []`;\n\n    java, C, C++是静态类型的\n\n\n\n    **然而因此有人认为需要显式的声明变量类型的语言,但是这是错!!的**\n\n    Haskell就是不需要显式声明类型的,但是它是静态的\n\n\n## 强弱类型语言之分\n+ 强类型: 偏向于不容忍隐式类型转换.\n\n 例如: python不容许'a'+1;\n\n```python\n>>> 'a'+1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't convert 'int' object to str implicitly\n\n```\n\n所以,python,ruby,java是强类型语言.\n\n+ 弱类型: 偏向于容忍隐式类型转换.\n\n 例如: javascript容许'a'+1\n\n```js\n> 'a'+1\n'a1'\n```\n\n所以: C,PHP都是弱类型语言\n\n**以上内容是不是有点颠覆三观?**","html":"<p>最近用空闲时间看了一本书&lt;冒号课堂>,内容虽然宽泛,但是仍读到了一些有用的知识,并纠正了一些关于语言上的错误概念.</p>\n\n<ul>\n<li><p>数据类型包含两个要素:</p>\n\n<ol><li>允许取值的集合</li>\n<li>允许参与的运算\n如: int在java中既定义了-2的31次方和2的31次方减一的整数集合, 也定义了该集合上的整数能进行的运算 </li></ol></li>\n<li><p>数据类型的意义</p></li>\n</ul>\n\n<blockquote>\n  <p>限定一个变量的数据类型，就意味着限制了该变量的取值范围和所参与的运算，这从一定程度上保证了代码的安全性</p>\n</blockquote>\n\n<h2 id=\"\">动静态类型语言</h2>\n\n<ul>\n<li><p>动态类型语言\n类型检查发生在运行期间,编译的时候就知道每一个变量的类型,因为类型错误而不能做的事情是语法错误.</p>\n\n<p>python,php,javascript是动态类型的</p></li>\n<li><p>静态类型语言\n类型检查发生在运行之前,编译的时候不知道每一个变量的类型,因为类型错误而不能做的事情是运行时错误.譬如说你不能对一个数字 a 写 a[10] 当数组用,并且可以在运行期间改变变量的类型</p>\n\n<p>例如: <code>a = 0; a = []</code>;</p>\n\n<p>java, C, C++是静态类型的</p>\n\n<p><strong>然而因此有人认为需要显式的声明变量类型的语言,但是这是错!!的</strong></p>\n\n<p>Haskell就是不需要显式声明类型的,但是它是静态的</p></li>\n</ul>\n\n<h2 id=\"\">强弱类型语言之分</h2>\n\n<ul>\n<li><p>强类型: 偏向于不容忍隐式类型转换.</p>\n\n<p>例如: python不容许'a'+1;</p></li>\n</ul>\n\n<pre><code class=\"language-python\">&gt;&gt;&gt; 'a'+1\nTraceback (most recent call last):  \n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: Can't convert 'int' object to str implicitly\n</code></pre>\n\n<p>所以,python,ruby,java是强类型语言.</p>\n\n<ul>\n<li><p>弱类型: 偏向于容忍隐式类型转换.</p>\n\n<p>例如: javascript容许'a'+1</p></li>\n</ul>\n\n<pre><code class=\"language-js\">&gt; 'a'+1\n'a1'  \n</code></pre>\n\n<p>所以: C,PHP都是弱类型语言</p>\n\n<p><strong>以上内容是不是有点颠覆三观?</strong></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464511858313,"created_by":1,"updated_at":1464512134788,"updated_by":1,"published_at":1464512001082,"published_by":1},{"id":10,"uuid":"76087552-4c1f-4c94-b29a-9700e9bec9b3","title":"递归还是迭代","slug":"di-gui-huan-shi-die-dai","markdown":"还是那本书<冒号课堂>,上看来的,这本书好处就是纠正了我一些错误的认知\n\n### 先打自己的脸\n我单纯的觉得迭代就是递归,或者是for循环 (啪~\n\n### 递归定义\n\n> 递归(英语：Recursion),又译为递回,在数学与计算机科学中,是指在函数的定义中使用函数自身的方法.递归一词还较常用于描述以自相似方法重复事物的过程.例如: 当两面镜子相互之间近似平行时,镜中嵌套的图像是以无限递归的形式出现的.也可以理解为自我复制的过程.  (wiki)\n\n\n### 迭代定义\n\n> 迭代是重复反馈过程的活动,其目的通常是为了接近并到达所需的目标或结果.每一次对过程的重复被称为一次 \"迭代\",而每一次迭代得到的结果会被用来作为下一次迭代的初始值. (wiki)\n\n> 在计算机科学中，迭代是程序中对一组指令（或一定步骤）的重复。它既可以被用作通用的术语（与 “重复” 同义），也可以用来描述一种特定形式的具有可变状态的重复。\n\n\n### 看到知乎一个关于这个问题的答案interesting\n\n```\n递归：\n】】】\n】】】】】】\n...\n】】】】】】】】】\n】】】】】】】】】】】】\n】】】】】】】】】\n...\n】】】】】】\n】】】\n\n迭代：\n】】】\n】】】\n】】】\n】】】\n...\n】】】\n】\n```\n\n### 举个栗子,计算n阶乘: \n\n+ 递归方法求n阶乘\n\n```js\nfunction fact(n) {\n    if (n === 1) {\n        return 1;\n    } else {\n        return n * fact(n-1);\n    }\n}\n```\n\n这个实现里,函数不断调用自身,所以这是一个迭代,它将一个大规模的问题,不断分解成小的问题进行求解.\n\n+ 迭代代方法\n\n```js\n\nfunction fact(n) {\n    function fact_iter(product, count, n) {\n        if (count > n) {\n            return product;\n        } else {\n            return fact_iter(product*count, count+1, n);\n        }\n    }\n    return fact_iter(1, 1, n);\n}\n\n```\n\n这个实现里,fact_iter也调用了自身,所以,在这种实现里,它是迭代也是递归\n\n\n+ 上面那个不好理解下面这个也是一样的\n\n```js\nfunction fact(n) {\n    var result = 1;\n    for(var i = i; i <= n; i ++) {\n        result *=i;\n    }\n    return result;\n}\n\n\n```\n\n第三种实现里,它是迭代,但是它并不是递归,\n他在循环中对result不断赋值,这种改变赋值----或者叫做**可变状态**---是迭代的特征\n\n\n### 计算过程展开\n\nfact(5); 我们把计算过程展开看看\n\n+ 递归\n\n```js\n\nfact(5);\n\n5 * fact(4);\n\n5 * 4 * fact(3);\n\n5 * 4 * 3 * fact(2);\n\n5 * 4 * 3 * 2 * fact(1);\n\n5 * 4 * 3 * 2 * 1;\n\n20 * 3 * 2 * 1;\n\n60 * 2 * 1;\n\n120 * 1;\n\n120\n\n\n```\n\n+ 迭代\n\n```js\n\nfact(5);\n\nfact_iter(1, 1, 5);\n\nfact_iter(1*1, 1+1, 5);\n\nfact_iter(1*2, 2+1, 5);\n\nfact_iter(2*3, 3+1, 5);\n\nfact_iter(6*4, 4+1, 5);\n\nfact_iter(24*5, 5+1, 5);\n\n120\n\n```\n\n+ 循环的迭代方法\n\n\n```js\n\nfact(5);\n\nresult = 1;\n\nresult = 1*1;\n\nresult = 1*2;\n\nresult = 2*3;\n\nresult = 6*4;\n\nresult = 24*5;\n\nresult = 120;\n\n120;\n\n```\n\n如你所见递归有一个展开到收缩的过程,而迭代没有.\n\n递归过程中, 问题的规模在缩小，这样最终得到问题的解；而迭代是一种由远变近的逼近，问题的规模不见得缩小了，但是慢慢在调整接近答案。递归求解 n 的阶乘过程，非常符合这个描述；\n\n\n> 迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。\n递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。\n\n所以,以我的理解,函数调用了自身,就是递归.\n\n不断重复一个过程,逐步逼近结果,则是迭代;\n\n### 优缺点\n迭代是在局部内存进行重复计算，递归需要展开栈空间进行每一步的函数现场存储和结果存储。迭代没有这个展开的开销\n\n### 参考 \n\n+ http://nxlhero.blog.51cto.com/962631/1231228\n\n+ https://www.wikiwand.com/zh/%E8%BF%AD%E4%BB%A3\n\n+ https://www.wikiwand.com/zh/%E9%80%92%E5%BD%92\n","html":"<p>还是那本书&lt;冒号课堂>,上看来的,这本书好处就是纠正了我一些错误的认知</p>\n\n<h3 id=\"\">先打自己的脸</h3>\n\n<p>我单纯的觉得迭代就是递归,或者是for循环 (啪~</p>\n\n<h3 id=\"\">递归定义</h3>\n\n<blockquote>\n  <p>递归(英语：Recursion),又译为递回,在数学与计算机科学中,是指在函数的定义中使用函数自身的方法.递归一词还较常用于描述以自相似方法重复事物的过程.例如: 当两面镜子相互之间近似平行时,镜中嵌套的图像是以无限递归的形式出现的.也可以理解为自我复制的过程.  (wiki)</p>\n</blockquote>\n\n<h3 id=\"\">迭代定义</h3>\n\n<blockquote>\n  <p>迭代是重复反馈过程的活动,其目的通常是为了接近并到达所需的目标或结果.每一次对过程的重复被称为一次 \"迭代\",而每一次迭代得到的结果会被用来作为下一次迭代的初始值. (wiki)</p>\n  \n  <p>在计算机科学中，迭代是程序中对一组指令（或一定步骤）的重复。它既可以被用作通用的术语（与 “重复” 同义），也可以用来描述一种特定形式的具有可变状态的重复。</p>\n</blockquote>\n\n<h3 id=\"interesting\">看到知乎一个关于这个问题的答案interesting</h3>\n\n<pre><code>递归：\n】】】\n】】】】】】\n...\n】】】】】】】】】\n】】】】】】】】】】】】\n】】】】】】】】】\n...\n】】】】】】\n】】】\n\n迭代：\n】】】\n】】】\n】】】\n】】】\n...\n】】】\n】\n</code></pre>\n\n<h3 id=\"n\">举个栗子,计算n阶乘:</h3>\n\n<ul>\n<li>递归方法求n阶乘</li>\n</ul>\n\n<pre><code class=\"language-js\">function fact(n) {  \n    if (n === 1) {\n        return 1;\n    } else {\n        return n * fact(n-1);\n    }\n}\n</code></pre>\n\n<p>这个实现里,函数不断调用自身,所以这是一个迭代,它将一个大规模的问题,不断分解成小的问题进行求解.</p>\n\n<ul>\n<li>迭代代方法</li>\n</ul>\n\n<pre><code class=\"language-js\">function fact(n) {  \n    function fact_iter(product, count, n) {\n        if (count &gt; n) {\n            return product;\n        } else {\n            return fact_iter(product*count, count+1, n);\n        }\n    }\n    return fact_iter(1, 1, n);\n}\n</code></pre>\n\n<p>这个实现里,fact_iter也调用了自身,所以,在这种实现里,它是迭代也是递归</p>\n\n<ul>\n<li>上面那个不好理解下面这个也是一样的</li>\n</ul>\n\n<pre><code class=\"language-js\">function fact(n) {  \n    var result = 1;\n    for(var i = i; i &lt;= n; i ++) {\n        result *=i;\n    }\n    return result;\n}\n</code></pre>\n\n<p>第三种实现里,它是迭代,但是它并不是递归,\n他在循环中对result不断赋值,这种改变赋值----或者叫做<strong>可变状态</strong>---是迭代的特征</p>\n\n<h3 id=\"\">计算过程展开</h3>\n\n<p>fact(5); 我们把计算过程展开看看</p>\n\n<ul>\n<li>递归</li>\n</ul>\n\n<pre><code class=\"language-js\">fact(5);\n\n5 * fact(4);\n\n5 * 4 * fact(3);\n\n5 * 4 * 3 * fact(2);\n\n5 * 4 * 3 * 2 * fact(1);\n\n5 * 4 * 3 * 2 * 1;\n\n20 * 3 * 2 * 1;\n\n60 * 2 * 1;\n\n120 * 1;\n\n120\n</code></pre>\n\n<ul>\n<li>迭代</li>\n</ul>\n\n<pre><code class=\"language-js\">fact(5);\n\nfact_iter(1, 1, 5);\n\nfact_iter(1*1, 1+1, 5);\n\nfact_iter(1*2, 2+1, 5);\n\nfact_iter(2*3, 3+1, 5);\n\nfact_iter(6*4, 4+1, 5);\n\nfact_iter(24*5, 5+1, 5);\n\n120\n</code></pre>\n\n<ul>\n<li>循环的迭代方法</li>\n</ul>\n\n<pre><code class=\"language-js\">fact(5);\n\nresult = 1;\n\nresult = 1*1;\n\nresult = 1*2;\n\nresult = 2*3;\n\nresult = 6*4;\n\nresult = 24*5;\n\nresult = 120;\n\n120;\n</code></pre>\n\n<p>如你所见递归有一个展开到收缩的过程,而迭代没有.</p>\n\n<p>递归过程中, 问题的规模在缩小，这样最终得到问题的解；而迭代是一种由远变近的逼近，问题的规模不见得缩小了，但是慢慢在调整接近答案。递归求解 n 的阶乘过程，非常符合这个描述；</p>\n\n<blockquote>\n  <p>迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。\n  递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。</p>\n</blockquote>\n\n<p>所以,以我的理解,函数调用了自身,就是递归.</p>\n\n<p>不断重复一个过程,逐步逼近结果,则是迭代;</p>\n\n<h3 id=\"\">优缺点</h3>\n\n<p>迭代是在局部内存进行重复计算，递归需要展开栈空间进行每一步的函数现场存储和结果存储。迭代没有这个展开的开销</p>\n\n<h3 id=\"\">参考</h3>\n\n<ul>\n<li><p><a href=\"http://nxlhero.blog.51cto.com/962631/1231228\">http://nxlhero.blog.51cto.com/962631/1231228</a></p></li>\n<li><p><a href=\"https://www.wikiwand.com/zh/%E8%BF%AD%E4%BB%A3\">https://www.wikiwand.com/zh/%E8%BF%AD%E4%BB%A3</a></p></li>\n<li><p><a href=\"https://www.wikiwand.com/zh/%E9%80%92%E5%BD%92\">https://www.wikiwand.com/zh/%E9%80%92%E5%BD%92</a></p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464518033233,"created_by":1,"updated_at":1464518217233,"updated_by":1,"published_at":1464518214264,"published_by":1},{"id":11,"uuid":"563436c0-e35e-4b9b-a1b8-fb0e8f7fbb3c","title":"git子模块","slug":"git-submodule","markdown":"### 前情提要\n\n最近在开发中遇到了一个问题: \n\n 我的写的一个 thinkphp 项目, 这个项目是用 git 做版本控制的, 它依赖了一个github 上开源的php类库request, 本来我应该用 composer 去管理这些依赖的, 但是懒惰的我直接在我的项目clone 了这个项目.然后引入它进行使用\n\n但是, 我在我的服务器上部署(直接从 github clone )这个项目的时候, 发生了一个问题: \n\n**找不到request这个类库了**\n\n我检查了一下项目目录, 发现 request 的文件夹是在的, 不过所有的文件都不在文件夹里面\n\n然而request的 .gitignore是在的, 我检查了一下它的.gitignore文件, 认为是.gitignore造成的问题, 然而, .gitignore只在我的项目目录下有效才对\n\n于是我捉急的 google 了一下:  `git 仓库 里面 还有 仓库` 结果得到一堆无关的答案, 什么如何创建仓库之类的..\n\n机智的我, 把关键字改了一改: `git repo containing git repo `\n\n结果: ![search_result](http://www.todoit.me/static/search_result.png)\n\n**~~我真是太机智了~~**\n\n**为什么我在服务器clone整个repo时, 子模块没有被 clone 下来?**\n\n**答案是: 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件 **\n\n\n\n### 以下是正文: \n\n\n\n### 什么是子模块?\n\n在开发过程中, 我们经常遇到这样的问题: 你的项目目录中包含了其他的项目目录, 或许它是一个第三方库, 或者是你独立开发的, 那么现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个怎么办?\n\nGit 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\n\n\n\n\n\n## 如何使用子模块?\n\n#### 在一个repo中创建一个子模块\n\n假定我们已经有一个主项目目录 major\n\n我们可以通过\n\n```shell\ngit submodule add <remote>\n```\n\n添加子模块\n\ne.g: \n\n```shell\ngit submodule add git@github.com:GiantMing/sub.git\n```\n\n它会把子模块 clone 到当前项目目录下, 并添加`.gitmodules`\n\n```shell\n[submodule \"sub\"]\n\tpath = sub\n\turl = git@github.com:GiantMing/sub.git\n```\n\npath 是子模块的目录, url 就是子模块的remote 地址了\n\n**注意: `.gitmodules`受到版本控制的。也就是说它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。**\n\n如果你需要把子模块添加到其他目录: \n\n```shell\ngit submodule add git@github.com:GiantMing/sub.git /path/you/want\n```\n\n#### 提交子模块\n\n如果我们运行\n\n```shell\ngit add sub\ngit commit -m 'add sub'\n```\n\n会发现\n\n```shell\n[master e87194b] add sub\n 2 files changed, 4 insertions(+)\n create mode 160000 sub\n```\n\n我们看到 sub 记录的是`160000` 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。**这意味着sub 并不会像普通的文件一样被父级仓库 track **\n\n\n\n#### 克隆含有子模块的项目\n\n前面说到: \n\n> 当你直接 git clone 一个包含子模块的项目时, 默认会包含该模块的目录, 但不会包含任何文件.\n\n那么怎么把子模块也 clone 下来?\n\n你必须运行两个命令：`git submodule init` 用来初始化本地配置文件，而 `git submodule update` 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。\n\n```shell\n$ git submodule init\nSubmodule 'sub' (git@github.com:GiantMing/sub.git) registered for path 'sub'\n\n$ git submodule update\nCloning into 'sub'...\nremote: Counting objects: 3, done.\nremote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0\nReceiving objects: 100% (3/3), done.\nChecking connectivity... done.\nSubmodule path 'sub': checked out '274194fdaab92394a7c15cdac2f10561f7ac11ee'\n```\n\n现在 clone 下来的 repo 就和刚才提交上去的一样了\n\n其实还有更加简单 clone 子模块的办法\n\n```shell\ngit clone --recursive git@github.com:GiantMing/major.git\n```\n\n`--recursive`会自动初始化并更新仓库中的每一个子模块.\n\n\n\n#### 拉取子模块的上游修改\n\n进入子模块所在目录\n\n```shell\ngit pull\n```\n\n如果你太懒了, 不想进到子模块里面去\n\n```shell\ngit submodule update --remote <submodule-name>  # 不加<submodule-name> 的话默认更新全部\n```\n\nGit 将会进入子模块然后抓取并更新\n\n此命令默认会假定你想要更新并 `checkout` 到子模块仓库的 `master` 分支。\n\n如果你想换其他分支, \n\n```shell\ngit config -f .gitmodules submodule.<submodule-name>.branch <branch-name> \n# <submodule-name> <branch-name>\n# 或者直接修改项目目录内的 .gitmodules\n# 或\ngit config submodule.<submodule-name>.branch <branch-name> \n# 区别是 不带-f .gitmodules 只更改了你自己的~/.gitconfig 文件只对自己生效, 所以推荐第一种\n```\n\n\n\n```shell\n[submodule \"sub\"]\n\tpath = sub\n\turl = git@github.com:GiantMing/sub.git\n\tbranch = <branch-name> # 这里是你想要的分支名\n```\n\n+ 查看子模块的 status\n\n  如果你开启了`status.submodulesummary`\n\n  ```shell\n  git config status.submodulesummary 1 # 开启子模块更新摘要\n  # 或者直接修改项目目录下.git/config\n  # 加上\n  [status]\n  \tsubmodulesummary = 1\n  ```\n\n  可以通过`git status`查看子模块的status\n\n\n\n#### 发布子模块的变动\n\n因为项目是依赖于子模块的, 所以你应该不会想主模块和子模块都提交了变动时主模块 push 上去, 而子模块保持你修改前的版本的\n\n`git  push` 的` --recurse-submodules` 参数可以帮助你解决这种烦恼\n\n` --recurse-submodules`有两个值 `check` 和 `on-demand`\n\n例如: \n\n```shell\ngit push --recurse-submodules=check\n```\n\n会检查你的子模块是否有修改并且发布变动, 如果有修改但是没有发布出去, 本次 push 就会失败\n\n同时, 它会建议你这样做\n\n1. 进入到子模块的模块, 一个个`git push` 上去\n2. 或者`git push --recurse-submodules=on-demand`\n\n`on-demand`参数会在主模块推送更新之前推送掉子模块, 如果子模块推送失败, 则主模块也会推送失败\n\n\n\n### 子模块技巧\n\n+ 子模块遍历 `git submodule foreach`\n\n  ```shell\n  git submodule foreach 'git status'\n  ```\n\n  进入到子模块中运行`git status`\n\n\n\n\n\n## 总结一下\n\n说到了这里, 我们再回到文章的开头看看\n\n子模块是: \n\n>  作为一个仓库子目录的仓库. 它能让你将另一个仓库克隆到自己的项目中，**同时还保持提交的独立.**\n\n所以, 我们可以将子模块当做一个独立的仓库使用\n\n但是, 为了别人用你的项目的时候, 很方便的 clone 项目, 用子模块应该是比较合适的处理方法\n\n\n\n好像解决了我多年的问题:\n\n+ github 上 的 repo里为什么会有灰色的打不开的文件夹?\n\n  因为子模块默认是不传上去的\n\n\n\n\n\n\n\n## 疑问\n\n其实我还是有一个疑问的,\n\n经过我反复的提交测试发现: \n\n如果子模块是一个空的 repo, 直接 clone 到主模块下, 然后进入子模块修改一些东西, 再提交主模块, 是会把子模块整个提交到仓库中的, 这算不算 git 的一个 bug ?\n\n (因为在其他情况下`git clone `, `git submodule add <submodulename>`都不能将子模块提交到 repo 中)\n\n\n\n### 说在最后\n\n折腾了大半天, 其实我最初的问题已经用最简单粗暴的方法解决了, ( 我把子模块整个 scp 到我的服务器上了\n\n为什么不用 composer install , 服务器装了半天都没装上 composer ( wget 半天 get 不到....\n\n感谢这个有包管理和版本控制的时代, maven, gem, composer, npm, yarn, 他们真的是很棒的东西,为我们处理了项目繁琐的库依赖, 和库升级带来的麻烦😛.","html":"<h3 id=\"\">前情提要</h3>\n\n<p>最近在开发中遇到了一个问题: </p>\n\n<p>我的写的一个 thinkphp 项目, 这个项目是用 git 做版本控制的, 它依赖了一个github 上开源的php类库request, 本来我应该用 composer 去管理这些依赖的, 但是懒惰的我直接在我的项目clone 了这个项目.然后引入它进行使用</p>\n\n<p>但是, 我在我的服务器上部署(直接从 github clone )这个项目的时候, 发生了一个问题: </p>\n\n<p><strong>找不到request这个类库了</strong></p>\n\n<p>我检查了一下项目目录, 发现 request 的文件夹是在的, 不过所有的文件都不在文件夹里面</p>\n\n<p>然而request的 .gitignore是在的, 我检查了一下它的.gitignore文件, 认为是.gitignore造成的问题, 然而, .gitignore只在我的项目目录下有效才对</p>\n\n<p>于是我捉急的 google 了一下:  <code>git 仓库 里面 还有 仓库</code> 结果得到一堆无关的答案, 什么如何创建仓库之类的..</p>\n\n<p>机智的我, 把关键字改了一改: <code>git repo containing git repo</code></p>\n\n<p>结果: <img src=\"http://www.todoit.me/static/search_result.png\" alt=\"search_result\" title=\"\" /></p>\n\n<p><strong><del>我真是太机智了</del></strong></p>\n\n<p><strong>为什么我在服务器clone整个repo时, 子模块没有被 clone 下来?</strong></p>\n\n<p><em>*答案是: 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件 *</em></p>\n\n<h3 id=\"\">以下是正文:</h3>\n\n<h3 id=\"\">什么是子模块?</h3>\n\n<p>在开发过程中, 我们经常遇到这样的问题: 你的项目目录中包含了其他的项目目录, 或许它是一个第三方库, 或者是你独立开发的, 那么现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个怎么办?</p>\n\n<p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>\n\n<h2 id=\"\">如何使用子模块?</h2>\n\n<h4 id=\"repo\">在一个repo中创建一个子模块</h4>\n\n<p>假定我们已经有一个主项目目录 major</p>\n\n<p>我们可以通过</p>\n\n<pre><code class=\"language-shell\">git submodule add &lt;remote&gt;  \n</code></pre>\n\n<p>添加子模块</p>\n\n<p>e.g: </p>\n\n<pre><code class=\"language-shell\">git submodule add git@github.com:GiantMing/sub.git  \n</code></pre>\n\n<p>它会把子模块 clone 到当前项目目录下, 并添加<code>.gitmodules</code></p>\n\n<pre><code class=\"language-shell\">[submodule \"sub\"]\n    path = sub\n    url = git@github.com:GiantMing/sub.git\n</code></pre>\n\n<p>path 是子模块的目录, url 就是子模块的remote 地址了</p>\n\n<p><strong>注意: <code>.gitmodules</code>受到版本控制的。也就是说它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</strong></p>\n\n<p>如果你需要把子模块添加到其他目录: </p>\n\n<pre><code class=\"language-shell\">git submodule add git@github.com:GiantMing/sub.git /path/you/want  \n</code></pre>\n\n<h4 id=\"\">提交子模块</h4>\n\n<p>如果我们运行</p>\n\n<pre><code class=\"language-shell\">git add sub  \ngit commit -m 'add sub'  \n</code></pre>\n\n<p>会发现</p>\n\n<pre><code class=\"language-shell\">[master e87194b] add sub\n 2 files changed, 4 insertions(+)\n create mode 160000 sub\n</code></pre>\n\n<p>我们看到 sub 记录的是<code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。<em>*这意味着sub 并不会像普通的文件一样被父级仓库 track *</em></p>\n\n<h4 id=\"\">克隆含有子模块的项目</h4>\n\n<p>前面说到: </p>\n\n<blockquote>\n  <p>当你直接 git clone 一个包含子模块的项目时, 默认会包含该模块的目录, 但不会包含任何文件.</p>\n</blockquote>\n\n<p>那么怎么把子模块也 clone 下来?</p>\n\n<p>你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>\n\n<pre><code class=\"language-shell\">$ git submodule init\nSubmodule 'sub' (git@github.com:GiantMing/sub.git) registered for path 'sub'\n\n$ git submodule update\nCloning into 'sub'...  \nremote: Counting objects: 3, done.  \nremote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0  \nReceiving objects: 100% (3/3), done.  \nChecking connectivity... done.  \nSubmodule path 'sub': checked out '274194fdaab92394a7c15cdac2f10561f7ac11ee'  \n</code></pre>\n\n<p>现在 clone 下来的 repo 就和刚才提交上去的一样了</p>\n\n<p>其实还有更加简单 clone 子模块的办法</p>\n\n<pre><code class=\"language-shell\">git clone --recursive git@github.com:GiantMing/major.git  \n</code></pre>\n\n<p><code>--recursive</code>会自动初始化并更新仓库中的每一个子模块.</p>\n\n<h4 id=\"\">拉取子模块的上游修改</h4>\n\n<p>进入子模块所在目录</p>\n\n<pre><code class=\"language-shell\">git pull  \n</code></pre>\n\n<p>如果你太懒了, 不想进到子模块里面去</p>\n\n<pre><code class=\"language-shell\">git submodule update --remote &lt;submodule-name&gt;  # 不加&lt;submodule-name&gt; 的话默认更新全部  \n</code></pre>\n\n<p>Git 将会进入子模块然后抓取并更新</p>\n\n<p>此命令默认会假定你想要更新并 <code>checkout</code> 到子模块仓库的 <code>master</code> 分支。</p>\n\n<p>如果你想换其他分支, </p>\n\n<pre><code class=\"language-shell\">git config -f .gitmodules submodule.&lt;submodule-name&gt;.branch &lt;branch-name&gt;  \n# &lt;submodule-name&gt; &lt;branch-name&gt;\n# 或者直接修改项目目录内的 .gitmodules\n# 或\ngit config submodule.&lt;submodule-name&gt;.branch &lt;branch-name&gt;  \n# 区别是 不带-f .gitmodules 只更改了你自己的~/.gitconfig 文件只对自己生效, 所以推荐第一种\n</code></pre>\n\n<pre><code class=\"language-shell\">[submodule \"sub\"]\n    path = sub\n    url = git@github.com:GiantMing/sub.git\n    branch = &lt;branch-name&gt; # 这里是你想要的分支名\n</code></pre>\n\n<ul>\n<li><p>查看子模块的 status</p>\n\n<p>如果你开启了<code>status.submodulesummary</code></p>\n\n<p>```shell\ngit config status.submodulesummary 1 # 开启子模块更新摘要</p>\n\n<h1 id=\"gitconfig\">或者直接修改项目目录下.git/config</h1>\n\n<h1 id=\"\">加上</h1>\n\n<p>[status]\n  submodulesummary = 1\n```</p>\n\n<p>可以通过<code>git status</code>查看子模块的status</p></li>\n</ul>\n\n<h4 id=\"\">发布子模块的变动</h4>\n\n<p>因为项目是依赖于子模块的, 所以你应该不会想主模块和子模块都提交了变动时主模块 push 上去, 而子模块保持你修改前的版本的</p>\n\n<p><code>git  push</code> 的<code>--recurse-submodules</code> 参数可以帮助你解决这种烦恼</p>\n\n<p><code>--recurse-submodules</code>有两个值 <code>check</code> 和 <code>on-demand</code></p>\n\n<p>例如: </p>\n\n<pre><code class=\"language-shell\">git push --recurse-submodules=check  \n</code></pre>\n\n<p>会检查你的子模块是否有修改并且发布变动, 如果有修改但是没有发布出去, 本次 push 就会失败</p>\n\n<p>同时, 它会建议你这样做</p>\n\n<ol>\n<li>进入到子模块的模块, 一个个<code>git push</code> 上去  </li>\n<li>或者<code>git push --recurse-submodules=on-demand</code></li>\n</ol>\n\n<p><code>on-demand</code>参数会在主模块推送更新之前推送掉子模块, 如果子模块推送失败, 则主模块也会推送失败</p>\n\n<h3 id=\"\">子模块技巧</h3>\n\n<ul>\n<li><p>子模块遍历 <code>git submodule foreach</code></p>\n\n<p><code>shell\ngit submodule foreach 'git status'\n</code></p>\n\n<p>进入到子模块中运行<code>git status</code></p></li>\n</ul>\n\n<h2 id=\"\">总结一下</h2>\n\n<p>说到了这里, 我们再回到文章的开头看看</p>\n\n<p>子模块是: </p>\n\n<blockquote>\n  <p>作为一个仓库子目录的仓库. 它能让你将另一个仓库克隆到自己的项目中，<strong>同时还保持提交的独立.</strong></p>\n</blockquote>\n\n<p>所以, 我们可以将子模块当做一个独立的仓库使用</p>\n\n<p>但是, 为了别人用你的项目的时候, 很方便的 clone 项目, 用子模块应该是比较合适的处理方法</p>\n\n<p>好像解决了我多年的问题:</p>\n\n<ul>\n<li><p>github 上 的 repo里为什么会有灰色的打不开的文件夹?</p>\n\n<p>因为子模块默认是不传上去的</p></li>\n</ul>\n\n<h2 id=\"\">疑问</h2>\n\n<p>其实我还是有一个疑问的,</p>\n\n<p>经过我反复的提交测试发现: </p>\n\n<p>如果子模块是一个空的 repo, 直接 clone 到主模块下, 然后进入子模块修改一些东西, 再提交主模块, 是会把子模块整个提交到仓库中的, 这算不算 git 的一个 bug ?</p>\n\n<p>(因为在其他情况下<code>git clone</code>, <code>git submodule add &lt;submodulename&gt;</code>都不能将子模块提交到 repo 中)</p>\n\n<h3 id=\"\">说在最后</h3>\n\n<p>折腾了大半天, 其实我最初的问题已经用最简单粗暴的方法解决了, ( 我把子模块整个 scp 到我的服务器上了</p>\n\n<p>为什么不用 composer install , 服务器装了半天都没装上 composer ( wget 半天 get 不到....</p>\n\n<p>感谢这个有包管理和版本控制的时代, maven, gem, composer, npm, yarn, 他们真的是很棒的东西,为我们处理了项目繁琐的库依赖, 和库升级带来的麻烦😛.</p>","image":"/content/images/2016/12/1458791372git.png","featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1480592556633,"created_by":1,"updated_at":1480592893596,"updated_by":1,"published_at":1480592893607,"published_by":1},{"id":12,"uuid":"76abfd00-aff2-44ab-bf5a-fdcafd16e595","title":"不用循环, 递归, 如何从1打印到100 ?","slug":"bu-yong-xun-huan-di-gui-ru-he-cong-1da-yin-dao-100","markdown":"昨晚在[伯乐在线](http://group.jobbole.com/22100/)看到这个题, 不过是 要求的 C++, 今早吃早餐的时候突发奇想想 js 不用 for 循环和递归怎么打印于是想到用 setInterval 实现\n\n```JavaScript\n\nvar i = 0;\n\nvar timer = setInterval(function() {\n    console.log(i++);\n    if(i > 100) \n        clearInterval(timer);\n});\n\n\n```\n\njust for fun~~","html":"<p>昨晚在<a href=\"http://group.jobbole.com/22100/\">伯乐在线</a>看到这个题, 不过是 要求的 C++, 今早吃早餐的时候突发奇想想 js 不用 for 循环和递归怎么打印于是想到用 setInterval 实现</p>\n\n<pre><code class=\"language-JavaScript\">var i = 0;\n\nvar timer = setInterval(function() {  \n    console.log(i++);\n    if(i &gt; 100) \n        clearInterval(timer);\n});\n</code></pre>\n\n<p>just for fun~~</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1481252020906,"created_by":1,"updated_at":1481252529331,"updated_by":1,"published_at":1481252529333,"published_by":1},{"id":13,"uuid":"a35f192e-2e3f-4ec9-91ff-32e05ca0dd38","title":"SSH配置笔记","slug":"ssh-conig","markdown":"# SSH 配置笔记\n\n其实我早就配好了..... 闲着无聊, 记记笔记.\n\n最近看到一些人的服务器被不知名的黑阔尝试用暴力破解root密码, 于是想到还好的之前把服务器的 ssh 密码登录关掉了..\n\n##### 关闭密码登录\n\n把 `/etc/ssh/sshd_config` 里的这个`PasswordAuthentication` 改成 `no`就好了.\n\n##### 生成密钥\n\n生成密钥用 ssh-keygen 命令\n\n```shell\nssh-keygen # 命令\n# 参数: \n-b  # 指定密钥长度； \n-e  # 读取openssh的私钥或者公钥文件； \n-C  # 添加注释； \n-f  # 指定用来保存密钥的文件名； \n-i  # 读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； \n-l # 显示公钥文件的指纹数据； \n-N  # 提供一个新密语； \n-P  # 提供（旧）密语； \n-q  # 静默模式； \n-t  # 指定要创建的密钥类型。\n```\n\n一般来说我们只会用到其中几个参数, 比如`-t`, `-b`, `-f`, `-C`\n\n比如我要专门对我的这台服务器生成一个密钥: \n\n```shell\nssh-keygen -t rsa -f ali_ssh_key -C '阿里云登录密钥'\n```\n\n运行后会询问你是否加密, 建议加密.\n\n一般来说, 加密方式有 rsa和 dsa, 这两种方式, 我其实也不懂这两种加密方式有什么区别, 只是感觉大家都用的 rsa\n\n把密钥存到文件 `ali_ssh_key`, 这会生成一对文件: 一个是 `ali_ssh_key` 保存着私钥, 另一个是 `ali_ssh_key.pub` 保存着公钥. ali_ssh_key.pub 里面, 最后一句就是 `-C`参数的内容, 用于方便自己区分密钥.\n\n\n\n##### 将公钥加入到主机上\n\n+ 手动加入到主机中\n\n  复制公钥贴到云主机的 ~/.ssh/authorized_keys里面, 一行一个公钥.\n\n+ 用 `ssh-copy-id`\n\n  ```shell\n  ssh-copy-id -i ali_ssh_key root@todoit.me # -p + 端口, 一般默认的就可以\n  ```\n\n  ssh-copy-id 其实干的事情是和上面说的手动改是一样的, 但是不用手动复制而已..\n\n\n\n然后就可以不用密码愉快得登录主机了~~\n\n### 但是\n\n手里的服务器多了, 难免会觉得记不住域名或者每次都要输一长串域名,越来越不愉快了, 所以想着用什么办法解决一下这个问题.\n\n## alias\n\n最开始的时候, 我是用 alias 去解决重复输入域名或者 ip 的问题的.\n\n比如我的这台阿里云服务器, 我这样写了一个 alias :\n\n```shell\nalias sshali='ssh root@todoit.me'\n```\n\n把这一句加到 `.bashrc` 或者 `.zshrc`里面去以后就可以很方便的输入 sshali 登录这台服务器了, 但是这样的话平时用 scp 上传下载东西的时候还是要输 ip 或者域名.\n\n于是看到了 .ssh/config这个愉快的东西\n\n### ssh config\n\n`ssh config` 可以方便我们管理自己的密钥, 登录主机, 可以给主机起别名\n\n这个配置, 需要放在自己的电脑上的`~/.ssh/config`里\n\n例如\n\n```shell\nHost ali  \t\t\t\t\t\t   # 主机名\n    HostName todoit.me  \t\t\t# 指定主机域名或者 ip 地址\n    User root\t\t\t\t\t    # 登录用户名\n    Port 22\t\t\t\t\t       # 主机 sshd 端口\n    IdentityFile ~/.ssh/ali_ssh_key  # 登录验证的私钥\n```\n\n这样, 就能愉快地用`ssh ali`登录我的这个主机了.\n\n对不同的主机, 用不同的私钥登录也是很方便的. 比如再生成一个密钥去登录腾讯云2333333\n\n这样 scp 也可以直接用:\n\n```shell\nscp  helloworld.sh ali:/xxx/xxx\n```\n\nssh 还有其他神奇的玩法了.. 我的玩法就到这里了..\n\n\n\n### 参考\n\n[ssh keys archlinux wiki](https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n\n[SSH 简化配置](https://gold.xitu.io/entry/5704cf8e71cfe4005dc76f18)\n\n","html":"<h1 id=\"ssh\">SSH 配置笔记</h1>\n\n<p>其实我早就配好了..... 闲着无聊, 记记笔记.</p>\n\n<p>最近看到一些人的服务器被不知名的黑阔尝试用暴力破解root密码, 于是想到还好的之前把服务器的 ssh 密码登录关掉了..</p>\n\n<h5 id=\"\">关闭密码登录</h5>\n\n<p>把 <code>/etc/ssh/sshd_config</code> 里的这个<code>PasswordAuthentication</code> 改成 <code>no</code>就好了.</p>\n\n<h5 id=\"\">生成密钥</h5>\n\n<p>生成密钥用 ssh-keygen 命令</p>\n\n<pre><code class=\"language-shell\">ssh-keygen # 命令  \n# 参数: \n-b  # 指定密钥长度； \n-e  # 读取openssh的私钥或者公钥文件； \n-C  # 添加注释； \n-f  # 指定用来保存密钥的文件名； \n-i  # 读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； \n-l # 显示公钥文件的指纹数据； \n-N  # 提供一个新密语； \n-P  # 提供（旧）密语； \n-q  # 静默模式； \n-t  # 指定要创建的密钥类型。\n</code></pre>\n\n<p>一般来说我们只会用到其中几个参数, 比如<code>-t</code>, <code>-b</code>, <code>-f</code>, <code>-C</code></p>\n\n<p>比如我要专门对我的这台服务器生成一个密钥: </p>\n\n<pre><code class=\"language-shell\">ssh-keygen -t rsa -f ali_ssh_key -C '阿里云登录密钥'  \n</code></pre>\n\n<p>运行后会询问你是否加密, 建议加密.</p>\n\n<p>一般来说, 加密方式有 rsa和 dsa, 这两种方式, 我其实也不懂这两种加密方式有什么区别, 只是感觉大家都用的 rsa</p>\n\n<p>把密钥存到文件 <code>ali_ssh_key</code>, 这会生成一对文件: 一个是 <code>ali_ssh_key</code> 保存着私钥, 另一个是 <code>ali_ssh_key.pub</code> 保存着公钥. ali<em>ssh</em>key.pub 里面, 最后一句就是 <code>-C</code>参数的内容, 用于方便自己区分密钥.</p>\n\n<h5 id=\"\">将公钥加入到主机上</h5>\n\n<ul>\n<li><p>手动加入到主机中</p>\n\n<p>复制公钥贴到云主机的 ~/.ssh/authorized_keys里面, 一行一个公钥.</p></li>\n<li><p>用 <code>ssh-copy-id</code></p>\n\n<p><code>shell\nssh-copy-id -i ali_ssh_key root@todoit.me # -p + 端口, 一般默认的就可以\n</code></p>\n\n<p>ssh-copy-id 其实干的事情是和上面说的手动改是一样的, 但是不用手动复制而已..</p></li>\n</ul>\n\n<p>然后就可以不用密码愉快得登录主机了~~</p>\n\n<h3 id=\"\">但是</h3>\n\n<p>手里的服务器多了, 难免会觉得记不住域名或者每次都要输一长串域名,越来越不愉快了, 所以想着用什么办法解决一下这个问题.</p>\n\n<h2 id=\"alias\">alias</h2>\n\n<p>最开始的时候, 我是用 alias 去解决重复输入域名或者 ip 的问题的.</p>\n\n<p>比如我的这台阿里云服务器, 我这样写了一个 alias :</p>\n\n<pre><code class=\"language-shell\">alias sshali='ssh root@todoit.me'  \n</code></pre>\n\n<p>把这一句加到 <code>.bashrc</code> 或者 <code>.zshrc</code>里面去以后就可以很方便的输入 sshali 登录这台服务器了, 但是这样的话平时用 scp 上传下载东西的时候还是要输 ip 或者域名.</p>\n\n<p>于是看到了 .ssh/config这个愉快的东西</p>\n\n<h3 id=\"sshconfig\">ssh config</h3>\n\n<p><code>ssh config</code> 可以方便我们管理自己的密钥, 登录主机, 可以给主机起别名</p>\n\n<p>这个配置, 需要放在自己的电脑上的<code>~/.ssh/config</code>里</p>\n\n<p>例如</p>\n\n<pre><code class=\"language-shell\">Host ali                             # 主机名  \n    HostName todoit.me              # 指定主机域名或者 ip 地址\n    User root                        # 登录用户名\n    Port 22                           # 主机 sshd 端口\n    IdentityFile ~/.ssh/ali_ssh_key  # 登录验证的私钥\n</code></pre>\n\n<p>这样, 就能愉快地用<code>ssh ali</code>登录我的这个主机了.</p>\n\n<p>对不同的主机, 用不同的私钥登录也是很方便的. 比如再生成一个密钥去登录腾讯云2333333</p>\n\n<p>这样 scp 也可以直接用:</p>\n\n<pre><code class=\"language-shell\">scp  helloworld.sh ali:/xxx/xxx  \n</code></pre>\n\n<p>ssh 还有其他神奇的玩法了.. 我的玩法就到这里了..</p>\n\n<h3 id=\"\">参考</h3>\n\n<p><a href=\"https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">ssh keys archlinux wiki</a></p>\n\n<p><a href=\"https://gold.xitu.io/entry/5704cf8e71cfe4005dc76f18\">SSH 简化配置</a></p>","image":"/content/images/2016/12/ssh-commands-cheatsheet.jpg","featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1482138333919,"created_by":1,"updated_at":1482138645433,"updated_by":1,"published_at":1482138645437,"published_by":1}],"users":[{"id":1,"uuid":"1546601a-4b9f-48a3-8bad-91e29e9d4f2d","name":"Ming","slug":"ming","password":"$2a$10$/Zgb4hDnUaBIU2vOfWxvG.R7TJYo63QxmWHbF.1ymAT2K8DoTwDLi","email":"i@todoit.me","image":"/content/images/2016/01/GiantMing-head.png","cover":null,"bio":"i@todoit.me","website":"http://todoit.me","location":"cqupt","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"tour":null,"last_login":1484495143387,"created_at":1451554901341,"created_by":1,"updated_at":1484495143388,"updated_by":1},{"id":2,"uuid":"9bcebe11-2711-4cc3-8b6d-a987b02777b6","name":"971334483","slug":"971334483","password":"$2a$10$VGzvDJy6uY1x011h8lWf1.EBCUchTCsXr2k9PjS0HakkKvSNIVKBi","email":"971334483@qq.com","image":null,"cover":null,"bio":null,"website":null,"location":null,"accessibility":null,"status":"invited","language":"en_US","meta_title":null,"meta_description":null,"tour":null,"last_login":null,"created_at":1451564977400,"created_by":1,"updated_at":1451564977400,"updated_by":1}],"roles":[{"id":1,"uuid":"9b73ead3-70b4-474b-a643-8f015f5054da","name":"Administrator","description":"Administrators","created_at":1451554896539,"created_by":1,"updated_at":1451554896539,"updated_by":1},{"id":2,"uuid":"d88c85c8-ee71-46c3-91ea-5edc3dd1189a","name":"Editor","description":"Editors","created_at":1451554896540,"created_by":1,"updated_at":1451554896540,"updated_by":1},{"id":3,"uuid":"0ea6f002-c671-450d-a267-f52de0fbfec0","name":"Author","description":"Authors","created_at":1451554896540,"created_by":1,"updated_at":1451554896540,"updated_by":1},{"id":4,"uuid":"7989c86d-b600-4811-b3f8-a49f517d2775","name":"Owner","description":"Blog Owner","created_at":1451554896540,"created_by":1,"updated_at":1451554896540,"updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1},{"id":2,"role_id":3,"user_id":2}],"permissions":[{"id":1,"uuid":"3d076dc4-7c61-435d-b1bf-d49ad680c098","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":1451554896833,"created_by":1,"updated_at":1451554896833,"updated_by":1},{"id":2,"uuid":"0ca4184d-9951-46da-8be4-296aca00af0f","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":1451554896858,"created_by":1,"updated_at":1451554896858,"updated_by":1},{"id":3,"uuid":"a27367b4-e48d-42b2-beb3-5dd8f8e81697","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":1451554896882,"created_by":1,"updated_at":1451554896882,"updated_by":1},{"id":4,"uuid":"1c73fa2a-e779-4dfc-ae30-88ee221c09f4","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":1451554896908,"created_by":1,"updated_at":1451554896908,"updated_by":1},{"id":5,"uuid":"68c57d93-8687-49d0-9165-d13bac6a4313","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":1451554896932,"created_by":1,"updated_at":1451554896932,"updated_by":1},{"id":6,"uuid":"b3b93fa9-9716-4ef8-b09c-f39aee50be4a","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":1451554896958,"created_by":1,"updated_at":1451554896958,"updated_by":1},{"id":7,"uuid":"016a453c-1038-46d8-9c3a-c8bb5ccf6b9b","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":1451554896982,"created_by":1,"updated_at":1451554896982,"updated_by":1},{"id":8,"uuid":"a7eda33d-77de-4c38-9eb4-9d408c8c16c1","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":1451554897006,"created_by":1,"updated_at":1451554897006,"updated_by":1},{"id":9,"uuid":"73cb3a0d-7371-4bc0-afaa-5d8a06cccb16","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":1451554897028,"created_by":1,"updated_at":1451554897028,"updated_by":1},{"id":10,"uuid":"e26e4b73-c90d-4f12-bef5-4accf4cce208","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1451554897054,"created_by":1,"updated_at":1451554897054,"updated_by":1},{"id":11,"uuid":"d7da50d5-cc25-418a-9fbc-7d0609aee71d","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":1451554897082,"created_by":1,"updated_at":1451554897082,"updated_by":1},{"id":12,"uuid":"cfdb0b05-13fa-4434-89bd-3b7a8274ebb5","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":1451554897104,"created_by":1,"updated_at":1451554897104,"updated_by":1},{"id":13,"uuid":"61549a8e-826d-4894-ab39-4b27292f018d","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":1451554897133,"created_by":1,"updated_at":1451554897133,"updated_by":1},{"id":14,"uuid":"7d883de7-df65-4031-b585-9e4d74c65f9b","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":1451554897159,"created_by":1,"updated_at":1451554897159,"updated_by":1},{"id":15,"uuid":"dcf02cd2-2efa-4681-bc04-26533d3eff41","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":1451554897192,"created_by":1,"updated_at":1451554897192,"updated_by":1},{"id":16,"uuid":"b1d9722c-b4fc-4457-a060-b2552d307596","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":1451554897220,"created_by":1,"updated_at":1451554897220,"updated_by":1},{"id":17,"uuid":"f748d9bb-7cf8-4236-84d4-4af9cfc1d368","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":1451554897248,"created_by":1,"updated_at":1451554897248,"updated_by":1},{"id":18,"uuid":"80653f01-d40e-49df-b68e-75ec83bcdfd5","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":1451554897269,"created_by":1,"updated_at":1451554897269,"updated_by":1},{"id":19,"uuid":"f351df20-02b7-4954-8c5e-a99f28bae8e7","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":1451554897288,"created_by":1,"updated_at":1451554897288,"updated_by":1},{"id":20,"uuid":"750f9c41-0090-4518-b818-93fbb3f4fe51","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":1451554897311,"created_by":1,"updated_at":1451554897311,"updated_by":1},{"id":21,"uuid":"5c1b5af4-c582-4ab1-bc82-25466074a872","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":1451554897332,"created_by":1,"updated_at":1451554897332,"updated_by":1},{"id":22,"uuid":"d7047c47-d52d-43be-989f-54c4b2da9788","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":1451554897353,"created_by":1,"updated_at":1451554897353,"updated_by":1},{"id":23,"uuid":"c02ce530-1ed6-4ac5-8ccb-df7a34b549fc","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":1451554897373,"created_by":1,"updated_at":1451554897373,"updated_by":1},{"id":24,"uuid":"26052b7f-cee2-42ab-a5e9-18ca5d0a9995","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":1451554897393,"created_by":1,"updated_at":1451554897393,"updated_by":1},{"id":25,"uuid":"ce135755-5705-4a9e-9b2b-c6f2d62fb1a0","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":1451554897413,"created_by":1,"updated_at":1451554897413,"updated_by":1},{"id":26,"uuid":"8317d8b4-b76f-45f1-92cf-e61fa66723db","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":1451554897434,"created_by":1,"updated_at":1451554897434,"updated_by":1},{"id":27,"uuid":"0958d0c3-2966-493f-ba28-7dc6ab733989","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":1451554897454,"created_by":1,"updated_at":1451554897454,"updated_by":1},{"id":28,"uuid":"f8b719c3-f735-4ed0-967a-d03f7791bc84","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":1451554897475,"created_by":1,"updated_at":1451554897475,"updated_by":1},{"id":29,"uuid":"adde5682-03f7-48a9-977d-6bc586189944","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":1451554897497,"created_by":1,"updated_at":1451554897497,"updated_by":1},{"id":30,"uuid":"f3b50e86-805e-4380-a329-6b98aac46fe3","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":1451554897520,"created_by":1,"updated_at":1451554897520,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_apps":[],"settings":[{"id":1,"uuid":"8fe74750-90c2-49f4-af4f-136f888c8f2f","key":"databaseVersion","value":"004","type":"core","created_at":1451554901412,"created_by":1,"updated_at":1451554901412,"updated_by":1},{"id":2,"uuid":"bb5001a8-f99b-4383-ab36-82821ff40ac4","key":"dbHash","value":"c87ca0c9-e8b1-4793-8bbe-5aec5ebb4653","type":"core","created_at":1451554901413,"created_by":1,"updated_at":1451554902004,"updated_by":1},{"id":3,"uuid":"8daf331c-8ada-4945-a1a5-006150fa37c1","key":"nextUpdateCheck","value":"1484581537","type":"core","created_at":1451554901413,"created_by":1,"updated_at":1484495137315,"updated_by":1},{"id":4,"uuid":"3e08512a-a2ce-4689-98e5-589767ebc43d","key":"displayUpdateNotification","value":"0.11.4","type":"core","created_at":1451554901414,"created_by":1,"updated_at":1484495137324,"updated_by":1},{"id":5,"uuid":"7afedb4b-d484-488b-814a-2e69d76908ec","key":"title","value":"Ming's blog","type":"blog","created_at":1451554901414,"created_by":1,"updated_at":1484495800012,"updated_by":1},{"id":6,"uuid":"36835fb8-da6c-4173-ae8f-a7b585f19ad7","key":"description","value":"写代码,要优雅~","type":"blog","created_at":1451554901414,"created_by":1,"updated_at":1484495800015,"updated_by":1},{"id":7,"uuid":"753025f2-3b38-4665-895b-d283e9ba142c","key":"logo","value":"/content/images/2016/03/9713344834F1255BA91CEAA032B46289F111AF2DE-1.jpg","type":"blog","created_at":1451554901414,"created_by":1,"updated_at":1484495800016,"updated_by":1},{"id":8,"uuid":"33eddc8c-5a63-48ba-b8e5-f04a83f07a06","key":"cover","value":"https://www.todoit.me/static/cover.jpg","type":"blog","created_at":1451554901415,"created_by":1,"updated_at":1484495800018,"updated_by":1},{"id":9,"uuid":"50d70a39-7cd7-4440-919b-4910c7bdff06","key":"defaultLang","value":"en_US","type":"blog","created_at":1451554901417,"created_by":1,"updated_at":1484495800019,"updated_by":1},{"id":10,"uuid":"3c1e0dc0-aa91-4215-886f-b2fe33ab6622","key":"postsPerPage","value":"10","type":"blog","created_at":1451554901417,"created_by":1,"updated_at":1484495800021,"updated_by":1},{"id":11,"uuid":"f926e6f1-b46c-4ade-90eb-5802a1f5f84e","key":"forceI18n","value":"true","type":"blog","created_at":1451554901417,"created_by":1,"updated_at":1484495800023,"updated_by":1},{"id":12,"uuid":"0ed435bf-4d64-4fbc-b4eb-2cede8f0c324","key":"permalinks","value":"/:slug/","type":"blog","created_at":1451554901418,"created_by":1,"updated_at":1484495800025,"updated_by":1},{"id":13,"uuid":"d5d30a5f-423a-499c-917c-430556c8d2bf","key":"ghost_head","value":"<script>\nvar _hmt = _hmt || [];\n(function() {\n  var hm = document.createElement(\"script\");\n  hm.src = \"//hm.baidu.com/hm.js?aec47a067678179c7bcfdec274352a34\";\n  var s = document.getElementsByTagName(\"script\")[0]; \n  s.parentNode.insertBefore(hm, s);\n})();\n</script>\n<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/tomorrow.min.css\">\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js\"></script>","type":"blog","created_at":1451554901418,"created_by":1,"updated_at":1484495800031,"updated_by":1},{"id":14,"uuid":"8ad1aed9-9c02-4951-b048-c1ba299d5c1b","key":"ghost_foot","value":"<script>hljs.initHighlightingOnLoad();</script>\n<script type=\"text/javascript\">     \n</script>","type":"blog","created_at":1451554901418,"created_by":1,"updated_at":1484495800033,"updated_by":1},{"id":15,"uuid":"89aee91c-d8fe-4529-8c69-da0aae652151","key":"labs","value":"{}","type":"blog","created_at":1451554901418,"created_by":1,"updated_at":1484495800034,"updated_by":1},{"id":16,"uuid":"a0cf2ae5-fb61-4d0a-92d5-0221a7bbb6bd","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"/\"},{\"label\":\"About\",\"url\":\"/about-me/\"},{\"label\":\"HongYan\",\"url\":\"http://hongyan.cqupt.edu.cn/aboutus/\"},{\"label\":\"Friends\",\"url\":\"/friends\"}]","type":"blog","created_at":1451554901418,"created_by":1,"updated_at":1484495800039,"updated_by":1},{"id":17,"uuid":"63c87817-0235-4d1a-9c4e-eb6323364c38","key":"activeApps","value":"[]","type":"app","created_at":1451554901419,"created_by":1,"updated_at":1451554901419,"updated_by":1},{"id":18,"uuid":"d7102514-b9f6-43d5-a04b-14c88d754cab","key":"installedApps","value":"[]","type":"app","created_at":1451554901419,"created_by":1,"updated_at":1484495373592,"updated_by":1},{"id":19,"uuid":"5ab1b399-39a0-4a2c-ac2b-95d2aee92346","key":"isPrivate","value":"false","type":"private","created_at":1451554901419,"created_by":1,"updated_at":1484495800040,"updated_by":1},{"id":20,"uuid":"dcd0f9ee-0dee-49d8-a669-1c27df0689b1","key":"password","value":"null","type":"private","created_at":1451554901420,"created_by":1,"updated_at":1484495800043,"updated_by":1},{"id":21,"uuid":"b05f4851-0ba9-41d1-bdbb-8af8a095d4c0","key":"activeTheme","value":"ghost-material","type":"theme","created_at":1451554901419,"created_by":1,"updated_at":1484495800027,"updated_by":1}],"tags":[{"id":2,"uuid":"3ffa5d6f-5c2f-4489-a6b9-3b7d0dba1017","name":"frontend","slug":"frontend","description":"giantming对于frontend的一些见解..,有什么不对的,不好的,欢迎指出","image":null,"hidden":0,"parent_id":null,"meta_title":"","meta_description":null,"created_at":1451577743027,"created_by":1,"updated_at":1451578180912,"updated_by":1},{"id":3,"uuid":"f3fd487c-073b-4d55-a0b5-a7a26c6b2ca5","name":"计算机基础","slug":"basis-of-computer-engineering","description":"GiantMing学习计算机基础知识的笔记,理解","image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1451578199245,"created_by":1,"updated_at":1451578333808,"updated_by":1},{"id":4,"uuid":"a5092ec4-efc7-421e-b776-f5ad97f7c9c5","name":"设计模式","slug":"she-ji-mo-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1462192031342,"created_by":1,"updated_at":1462192031342,"updated_by":1},{"id":5,"uuid":"7127a6d0-961a-4915-865d-05be35e51b0a","name":"算法","slug":"suan-fa","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1462192061720,"created_by":1,"updated_at":1462192061720,"updated_by":1},{"id":6,"uuid":"a207e1ed-bec2-45bf-bcc4-b78376aa4ed7","name":"hello world","slug":"hello-world","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1462192106871,"created_by":1,"updated_at":1462192106871,"updated_by":1},{"id":7,"uuid":"7cee3a66-b0f5-4d0b-b74b-f609a788fc8e","name":"编程语言","slug":"bian-cheng-yu-yan","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1464512074554,"created_by":1,"updated_at":1464512074554,"updated_by":1},{"id":8,"uuid":"a65d8fcf-ea29-4582-8e05-407523594505","name":"git","slug":"git","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1480592821625,"created_by":1,"updated_at":1480592821625,"updated_by":1},{"id":9,"uuid":"39ac6b23-80bf-45a3-a6ec-640f1cdce321","name":"JavaScript","slug":"javascript","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1480904478263,"created_by":1,"updated_at":1480904478263,"updated_by":1},{"id":10,"uuid":"fa8cc6a5-b4ee-4668-9a77-6fed911a6a7c","name":"nodejs","slug":"nodejs","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1480904478274,"created_by":1,"updated_at":1480904478274,"updated_by":1},{"id":11,"uuid":"2c7981f0-1680-44ab-a02d-02dda1e42ab2","name":"笔记","slug":"bi-ji","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1482138594682,"created_by":1,"updated_at":1482138594682,"updated_by":1},{"id":12,"uuid":"a16fd946-01da-42f8-a139-d9cbc3938a31","name":"linux","slug":"linux","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1482138594691,"created_by":1,"updated_at":1482138594691,"updated_by":1},{"id":13,"uuid":"596b613d-db6a-4ff3-a140-d436103408ca","name":"ssh","slug":"ssh","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1482138594696,"created_by":1,"updated_at":1482138594696,"updated_by":1},{"id":14,"uuid":"e17e850e-a7b7-4bd2-918b-58b29201c9eb","name":"运维","slug":"yun-wei","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1482138594702,"created_by":1,"updated_at":1482138594702,"updated_by":1}],"posts_tags":[{"id":2,"post_id":7,"tag_id":4,"sort_order":0},{"id":3,"post_id":5,"tag_id":5,"sort_order":0},{"id":4,"post_id":3,"tag_id":6,"sort_order":0},{"id":5,"post_id":9,"tag_id":7,"sort_order":0},{"id":6,"post_id":10,"tag_id":7,"sort_order":0},{"id":7,"post_id":11,"tag_id":8,"sort_order":0},{"id":8,"post_id":7,"tag_id":9,"sort_order":1},{"id":9,"post_id":7,"tag_id":10,"sort_order":2},{"id":10,"post_id":13,"tag_id":11,"sort_order":0},{"id":11,"post_id":13,"tag_id":12,"sort_order":1},{"id":12,"post_id":13,"tag_id":13,"sort_order":2},{"id":13,"post_id":13,"tag_id":14,"sort_order":3}],"apps":[],"app_settings":[],"app_fields":[],"client_trusted_domains":[]}}]}